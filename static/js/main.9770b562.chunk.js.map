{"version":3,"sources":["Todolist/Todoinput.js","Todolist/Todoing.js","Todolist/Todolist.js","index.js"],"names":["Todoinput","handleInput","e","keyCode","props","add","target","value","handleChange","setState","name","state","a","b","c","this","focus","ref","inp","onChange","onKeyDown","type","Number","onClick","console","log","Component","Todoing","todo","map","item","idx","key","del","defaultProps","Todolist","addItem","data","delItem","splice","obj","o","JSON","parse","stringify","Object","keys","forEach","ReactDOM","render","document","getElementById","className"],"mappings":"4PAKqBA,E,YACjB,aAAe,IAAD,8BACV,+CAQJC,YAAc,SAACC,GAEM,KAAdA,EAAEC,SAED,EAAKC,MAAMC,IAAIH,EAAEI,OAAOC,QAblB,EAgBdC,aAAe,SAACN,GACZ,EAAKO,SAAL,eACKP,EAAEI,OAAOI,KAAOR,EAAEI,OAAOC,SAf9B,EAAKI,MAAQ,CACTC,EAAG,GACHC,EAAG,GACHC,EAAG,IANG,E,iFAuBVC,KAAKH,EAAEI,U,+BAED,IAAD,OACL,OACI,6BAGI,2BAAOC,IAAK,SAACC,GAAO,EAAKN,EAAEM,GAAMR,KAAK,IAAIS,SAAUJ,KAAKP,aAAcD,MAAOQ,KAAKJ,MAAMC,EAAGQ,UAAWL,KAAKd,YAAaoB,KAAK,SAHlI,IAKI,2BAAOX,KAAK,IAAIS,SAAUJ,KAAKP,aAAcD,MAAOQ,KAAKJ,MAAME,EAAGO,UAAWL,KAAKd,YAAaoB,KAAK,SALxG,IAOI,2BAAOX,KAAK,IAAIS,SAAUJ,KAAKP,aAAcD,MAAOQ,KAAKJ,MAAMG,EAAGM,UAAWL,KAAKd,YAAaoB,KAAK,SAPxG,IASI,2BAAIC,OAAOP,KAAKJ,MAAMC,GAAGU,OAAOP,KAAKJ,MAAME,GAAGS,OAAOP,KAAKJ,MAAMG,IAEhE,2BAAOO,KAAK,OAAOJ,IAAK,SAACC,GAAO,EAAKA,IAAIA,KACzC,4BAAQK,QAAS,WAAKC,QAAQC,IAAI,EAAKP,IAAIX,SAA3C,qB,GAxCuBmB,aCDlBC,E,iLAIP,IAAD,OACAC,EAAQb,KAAKX,MAAbwB,KACL,OACI,4BAGQA,EAAKC,KAAI,SAACC,EAAKC,GAAN,OAAc,wBAAIC,IAAKD,GAAMD,EAAf,KAAsB,4BAAQP,QAAS,SAACrB,GAAD,OAAK,EAAKE,MAAM6B,IAAIF,EAAI7B,KAAzC,yB,GAV5BwB,aAyBrCC,EAAQO,aAAe,CACnBN,KAAM,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,I,IC3BAO,E,YACjB,aAAe,IAAD,uBACV,+CAuBJC,QAAU,SAACC,GAEP,EAAK5B,SAAS,CACVmB,KAAK,GAAD,mBAAK,EAAKjB,MAAMiB,MAAhB,CAAqBS,OA3BnB,EA8BdC,QAAU,SAACP,EAAI7B,GAMX,IAAI0B,EAAI,YAAO,EAAKjB,MAAMiB,MAC1BA,EAAKW,OAAOR,EAAI,GAChB,EAAKtB,SAAS,CACVmB,KAAKA,IAGP,WACEJ,QAAQC,IAAI,EAAKd,MAAMiB,UAzC3B,EAAKjB,MAAQ,CACTiB,KAAK,CAAC,EAAE,EAAE,IAGd,IAAIY,EAAM,CAAC5B,EAAE,IAAIC,EAAE,CAAC,EAAE,EAAE,IAGpB4B,EAAIC,KAAKC,MAAMD,KAAKE,UAAUJ,IATxB,OAYVC,EAAE5B,EAAE,GAAK,IACTW,QAAQC,IAAIe,GACZhB,QAAQC,IAAIgB,GACZjB,QAAQC,IAAIgB,IAAMD,GAGlBK,OAAOC,KAAKN,GAAKO,SAAQ,SAACjB,GACtBN,QAAQC,IAAIK,GACZN,QAAQC,IAAIe,EAAIV,OApBV,E,sEAgDV,OACI,6BACI,kBAAC,EAAD,CAAWzB,IAAKU,KAAKqB,UACrB,kBAAC,EAAD,CAASH,IAAKlB,KAAKuB,QAASV,KAAMb,KAAKJ,MAAMiB,Y,GApDvBF,aCKtCsB,IAASC,OACL,kBAAC,EAAD,MACAC,SAASC,eAAe,SA8HlBD,SAASC,eAAe,QAC9BC,UAAY,W","file":"static/js/main.9770b562.chunk.js","sourcesContent":["import React, { Component } from 'react'\r\n// 受控组件：value值被react控制的表单元素\r\n// 可以实时获取表单元素的值（表单验证）  /写法相对麻烦\r\n// \r\n\r\nexport default class Todoinput extends Component {\r\n    constructor() {\r\n        super();\r\n        // this.handleInput = this.handleInput.bind(this);\r\n        this.state = {\r\n            a: '',\r\n            b: '',\r\n            c: ''\r\n        }\r\n    }\r\n    handleInput = (e) => { \r\n        // （绑定this的方式）事件处理函数改为箭头函数；也可以使用bind\r\n        if(e.keyCode === 13) {\r\n            // e.target发生事件的根本元素\r\n            this.props.add(e.target.value);\r\n        }    \r\n    }\r\n    handleChange = (e) => {\r\n        this.setState({\r\n            [e.target.name]: e.target.value\r\n        })\r\n    }\r\n    componentDidMount() {\r\n        // render 之后执行，所以能找到\r\n        this.a.focus();\r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                {/* 受控组件 */}\r\n                {/* 以后不用value，用defaultValue */}\r\n                <input ref={(inp)=>{this.a=inp}} name='a' onChange={this.handleChange} value={this.state.a} onKeyDown={this.handleInput} type='text'/>\r\n                +\r\n                <input name='b' onChange={this.handleChange} value={this.state.b} onKeyDown={this.handleInput} type='text'/>\r\n                +\r\n                <input name='c' onChange={this.handleChange} value={this.state.c} onKeyDown={this.handleInput} type='text'/>\r\n                =\r\n                <p>{Number(this.state.a)+Number(this.state.b)+Number(this.state.c)}</p>\r\n                {/* 非受控组件：一次性获取或处理表单元素的值 */}\r\n                <input type='text' ref={(inp)=>{this.inp=inp}}></input>\r\n                <button onClick={()=>{console.log(this.inp.value)}}>提交</button>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\n// 受控组件：\r\n// 1、给input标签添加value属性，赋值为state的值\r\n// 2、给input标签绑定onChange事件，\r\n// 在事件处理函数中setState\r\n// 3、一个事件处理函数控制多个表单元素时，\r\n// 给input标签加上name属性,事件处理函数中写：\r\n// setState({[e.target.name]:e.target.value})","import React, { Component } from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\n\r\nexport default class Todoing extends Component {\r\n    // delItem(idx,e) {\r\n    //     this.props.del(idx);\r\n    // }\r\n    render() {\r\n        var {todo} = this.props;\r\n        return (\r\n            <ul>\r\n                {\r\n                    // map 是数组上的方法\r\n                    todo.map((item,idx) => <li key={idx}>{item}  <button onClick={(e)=>this.props.del(idx,e)}>删除</button></li>) // 不是语句，不要写分号\r\n                                                                                 // 相当于在this.props.del(idx)外边又套了一层函数\r\n                                                                                 // 不能直接用this.props.del(idx)，因为这个是函数执行完后的返回值\r\n                                                                                 // 如上：事件处理函数中，既想要得到普通参数，又想得到事件对象e；\r\n                                                                                 // 事件对象永远作为最后一个参数\r\n                    // todo.map((item,idx) => <li key={idx}>{item}  <button onClick={this.delItem.bind(this)}>删除</button></li>)\r\n                }\r\n            </ul>\r\n        )\r\n    }\r\n}\r\nTodoing.propTypes = {\r\n    todo: PropTypes.array,\r\n    del: PropTypes.func\r\n}\r\nTodoing.defaultProps = {\r\n    todo: [1,2,3,4,5,6]\r\n}","import React, { Component } from 'react'\r\nimport Todoinput from './Todoinput'\r\nimport Todoing from './Todoing'\r\nexport default class Todolist extends Component {\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            todo:[1,2,3]\r\n        }\r\n        // 深拷贝/浅拷贝\r\n        var obj = {a:100,b:[1,2,3]};\r\n        var obj1 = {c:300}\r\n        // var o = {...obj}; // 浅拷贝\r\n        var o = JSON.parse(JSON.stringify(obj));// 深拷贝\r\n        // var o = Object.assign(obj,obj1);// o===obj\r\n        // var o = Object.assign({},obj,obj1);\r\n        o.b[0] = 200;\r\n        console.log(obj);\r\n        console.log(o);\r\n        console.log(o === obj);\r\n\r\n        // 遍历对象\r\n        Object.keys(obj).forEach((item) => { // Object.keys(obj)是obj属性名组成的数组\r\n            console.log(item);\r\n            console.log(obj[item]);\r\n            // obj.item 表示属性的名字是\"item\"\r\n        })\r\n    }\r\n    addItem = (data) => {\r\n        // 改变状态\r\n        this.setState({\r\n            todo:[...this.state.todo,data]\r\n        })        \r\n    }\r\n    delItem = (idx,e) => {\r\n        /**\r\n            * 1、不能直接改变或处理state，通过setState改变\r\n            * 2、setState 是异步执行的\r\n         */\r\n        // 不要在原来的值上修改，拷贝一份\r\n        let todo = [...this.state.todo];\r\n        todo.splice(idx,1); // 删除数组中的某一项(从哪一项开始删，删除几个)\r\n        this.setState({\r\n            todo:todo\r\n            // todo\r\n            // 值和变量名一样，可以写为 todo\r\n        },() => {\r\n            console.log(this.state.todo);\r\n        })  \r\n        // console.log(this.state.todo);\r\n    }\r\n    render() { // 只要属性或状态变，会自动更新\r\n        return (\r\n            <div>\r\n                <Todoinput add={this.addItem}/>\r\n                <Todoing del={this.delItem} todo={this.state.todo}/>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\n\r\n// 因为是异步执行，所以得到的this.state.num可能会出错，不是自己想要的数（在this.setState()代码后可能会对this.state.num进行操作）\r\n// this.setState({\r\n//     todo:this.state.num + 100\r\n// }) \r\n\r\n\r\n// 这种方法可以解决上边的问题\r\n// this.setState((state,props) => {\r\n//     return {\r\n//         todo:this.state.num + 100\r\n//     }    \r\n// }) ","import React,{Fragment,Component} from 'react'; // {Fragment}：解构赋值\nimport ReactDOM from 'react-dom';\n// import ShowTime from './Showtime'; // 如果引入的文件是js文件，不用加后缀名。其余都要加\nimport './index.css';\nimport Todolist from './Todolist/Todolist';\n//import * as serviceWorker from './serviceWorker';\n\n\nReactDOM.render(\n    <Todolist/>,\n    document.getElementById('root')\n);\n// 函数声明组件\n// function ShowTime(props){\n//     console.log(props);\n       // 返回值必须包裹在一对闭合标签内\n//     return (<Fragment>\n//                 <div>{props.name}{props.age}</div>\n//                 <div>\n//                     {new Date().toLocaleString()}\n//                 </div>\n//             </Fragment>\n//         )\n// }\n\n/**\n * 组件交互\n * 父组件--->子组件：调用子组件时添加属性，子组件通过props拿到传递的数据\n * 子组件--->父组件：\n */\n// var num = [1,2,3,4,5];\n// ReactDOM.render(\n//     <ShowTime name=\"zhangsan\" age={num}/>,\n//     document.getElementById('root')\n// )\n\n\n// 显示当前系统时间\n// function showTime() {\n//     var ele = <div>{new Date().toLocaleString()}</div>;\n//     ReactDOM.render(\n//         ele,\n//         document.querySelector('#root')\n//     )\n// }\n// showTime();\n// setInterval(showTime,1000);\n\n\n// 自己封装的render函数\nvar obj = {\n    type: 'div',\n    props: {\n        id: 'tit',\n        class: 'tit',\n        children: [\n            'hello',\n            ' react',\n            {\n                type: 'h1',\n                props: {\n                    id: 'tit',\n                    class: 'tit',\n                    children: [\n                        'hello',\n                        ' react'                        \n                    ]\n                }\n            }\n        ]\n    }\n}\nfunction render(obj,container) {\n    var {type,props} = obj;\n    // 文档碎片,一个变量，相当于虚拟节点\n    var fragment = document.createDocumentFragment();\n    var ele = document.createElement(type);\n    for(var item in props) {\n        if(item === 'class') {\n            ele.className = props[item];\n        }else if(item === 'children') {\n            for(var i = 0; i < props.children.length; i++) {\n                // ele.innerHTML += props.children[i];\n                if(typeof props.children[i] === 'object') {\n                    render(props.children[i],ele);\n                }else {\n                    var txt = document.createTextNode(props.children[i]);\n                    ele.appendChild(txt);\n                }\n            }\n        }else {\n            ele[item] = props[item]; // .item表示obj中要有一个属性（名字为item）\n        }\n    }\n    fragment.appendChild(ele);\n    container.appendChild(fragment);\n}\n// render(obj, document.getElementById('root'));\n\n\n\n\n/**\n * 页面渲染过程：\n * 请求HTML页面、浏览器HTML解析器解析html文件、生成dom树\n * link引入css文件、css解析器解析css，生成css对象模型（CSSOM），\n * CSSOM和DOM tree结合生成一个render tree，最后浏览器绘制页面。\n */\n// 页面回流（重排reflow）：DOM结构变化、内容变化、大小、位置的变化、显示或隐藏的变化\n// 页面重绘（repaint）：颜色的变化（背景色，字体颜色、边框颜色）\n// 回流一定会引起重绘，重绘不一定引起回流；回流的代价是最大的\n\n\n//                                             1、先用变量进行dom处理，最后一次渲染\n// console.time('time');\n// var div = document.getElementById(\"root\");\n// var stri = '';\n// for(var i = 0; i < 1000; i++) {\n//     // 不要直接用innerHTML +=，太费时间\n//     stri += '<p>' + i + '</p>';\n// }\n// div.innerHTML = stri;\n// console.timeEnd('time');\n// console.time('time1');\n// var div = document.getElementById(\"root\");\n// for(var i = 0; i < 1000; i++) {\n//     // 不要直接用innerHTML +=，太费时间\n//     div.innerHTML += '<p>' + i + '</p>';\n// }\n// console.timeEnd('time1');\n//                                              2、对于样式处理，声明一个css类\n// var div = document.getElementById(\"root\");\n// div.style.width = '100px';\n// div.style.height = '100px';\n// div.style.background = 'pink';\n\nvar div = document.getElementById(\"root\");\ndiv.className = 'active';\n//                                              3、offsetLeft、offsetWidth会引起回流，要慎用\n// setInterval(() => {\n//     div.style.width = div.offsetLeft + 1 + 'px';\n// },100);\n\n// var wid = div.offsetWidth; // 这种方式，只调一次\n// setInterval(() => {\n//     wid += 1;\n//     div.style.width = wid + 'px';\n// },100);\n//                                               4、文档碎片（内存中的一个变量）\n\n\n\n/**\n * react 技术栈\n * \n */\n// var str = 'react';\n// var ele = <h1 class=\"tit\">hello <p>react</p>{str}</h1>;\n// var ele = React.createElement(\n//     'h1',\n//     {id:'tit',class:'title'},\n//     'hello',\n//     React.createElement(\n//         'p',\n//         {id:'p',class:'p'},\n//         'react'\n//     )\n// );\n// ReactDOM.render(ele, document.getElementById('root'));"],"sourceRoot":""}